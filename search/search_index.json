{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"About Putares Victoria Proreus plagarum Lorem markdownum! Et iras es concubitus , ubi Pergama nostras praeferret, solvit novitate tribuente mixta facerent, haec mea amans iram. Magis quaerenti usque adhuc Acheloiadumque spatiosum candore, his ita pariter Mopso imagine gloria sum venit fecisse virginibus. Figuram leporem ruinas procul patentibus vultus Et solibus frondes cursibus primus sternitur tela spinas fuisset, umbram subdita, nunc lacertis certae. Meruisse non carpitque vestigia me cruorem anima cum isse vatum magnum ait. Ossa dei tenentes, in levi est, in abit, mole Phaethon vidit, vescitur parva contigerant. Nodis quemquam sacra rigent, et et subibis matre petitur sub temporis coeptum adice, exta. Illa domos umeris solvit verum obstiterit veniat, cum etiamnum cultos indiciique, quae et terra. Capientur cornibus Mora et! Illa primus , haerent regnum habet iam longis proles solita; nomenque trahens tamen. Stagnum exitus per Eurytidos vivis occultat habuit famem reppulit Cephesidas semimarem certe. Ille saepe numinis verte pariterque hospes. Est ille inmenso Iuppiter! Filia exegit nec portarum, esto rerum quodsi virum. Tua spuma est iugulum talibus. Mutataque omnes Achilli dextra , animi resumptis, suaque, est per torquet ades. Tempore suo et eodem Rogaberis arvo ipse: sermo inter rigido Zanclen, et irasci thalamo regia latentia. Condidit conplevit cladis virtus et mihi nec arma. Fauni remorata silentia blanditiis supremum forte notissima Serius me magnum suis belli ulterius non Est ad singultibus precibusque Hesperiosque Cyllenius tangunt Nostro dei Frenisque verti. Nec labi induruit color quique nebulasque postquam corvo aures , tot morte pallae. Fide intellege coepit humana : ait collo quoque; nec est, quique.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#putares-victoria-proreus-plagarum","text":"Lorem markdownum! Et iras es concubitus , ubi Pergama nostras praeferret, solvit novitate tribuente mixta facerent, haec mea amans iram. Magis quaerenti usque adhuc Acheloiadumque spatiosum candore, his ita pariter Mopso imagine gloria sum venit fecisse virginibus.","title":"Putares Victoria Proreus plagarum"},{"location":"about/#figuram-leporem-ruinas-procul-patentibus-vultus","text":"Et solibus frondes cursibus primus sternitur tela spinas fuisset, umbram subdita, nunc lacertis certae. Meruisse non carpitque vestigia me cruorem anima cum isse vatum magnum ait. Ossa dei tenentes, in levi est, in abit, mole Phaethon vidit, vescitur parva contigerant. Nodis quemquam sacra rigent, et et subibis matre petitur sub temporis coeptum adice, exta. Illa domos umeris solvit verum obstiterit veniat, cum etiamnum cultos indiciique, quae et terra.","title":"Figuram leporem ruinas procul patentibus vultus"},{"location":"about/#capientur-cornibus","text":"Mora et! Illa primus , haerent regnum habet iam longis proles solita; nomenque trahens tamen. Stagnum exitus per Eurytidos vivis occultat habuit famem reppulit Cephesidas semimarem certe. Ille saepe numinis verte pariterque hospes. Est ille inmenso Iuppiter! Filia exegit nec portarum, esto rerum quodsi virum. Tua spuma est iugulum talibus. Mutataque omnes Achilli dextra , animi resumptis, suaque, est per torquet ades.","title":"Capientur cornibus"},{"location":"about/#tempore-suo-et-eodem","text":"Rogaberis arvo ipse: sermo inter rigido Zanclen, et irasci thalamo regia latentia. Condidit conplevit cladis virtus et mihi nec arma. Fauni remorata silentia blanditiis supremum forte notissima Serius me magnum suis belli ulterius non Est ad singultibus precibusque Hesperiosque Cyllenius tangunt Nostro dei Frenisque verti. Nec labi induruit color quique nebulasque postquam corvo aures , tot morte pallae. Fide intellege coepit humana : ait collo quoque; nec est, quique.","title":"Tempore suo et eodem"},{"location":"linux/","text":"Pygments pygmentize -L styles lists available highlighting styles pygmentize -g -P style=monokai <file> (-g is guess) don't cat grep works fine without it. view does a readonly vim, some as vi -","title":"tailor"},{"location":"linux/#pygments","text":"pygmentize -L styles lists available highlighting styles pygmentize -g -P style=monokai <file> (-g is guess)","title":"Pygments"},{"location":"linux/#dont-cat","text":"grep works fine without it. view does a readonly vim, some as vi -","title":"don't cat"},{"location":"linux/awk-short/","text":"deduplicate while keeping order awk '!visited[$0]++' your_file > deduplicated_file ( visited is a map whose keys are the contents of each line. The key variable is \"occurrences\" in awk 0 is false, all else true, so only lines whose occurence is equal to zero get flipped to true and printed {print $0} is implied if omitted. )","title":"awk-shorts"},{"location":"linux/awk-short/#deduplicate-while-keeping-order","text":"awk '!visited[$0]++' your_file > deduplicated_file ( visited is a map whose keys are the contents of each line. The key variable is \"occurrences\" in awk 0 is false, all else true, so only lines whose occurence is equal to zero get flipped to true and printed {print $0} is implied if omitted. )","title":"deduplicate while keeping order"},{"location":"linux/awk-short/#_1","text":"","title":""},{"location":"ssh/","text":"generate, copy, connect ! keygen lets say we do ed25519 ssh-keygen -o -a 100 -t ed25519 - o signifies an option follows - a is argument to -o, says to do 100 \"rounds\" - this option specifies the number of KDF (key derivation function) rounds to use. Higher numbers result in slower passphrase verification and increased resistance to brute- force password cracking. - passphrase (aka fingerprint) is optional - it secures the private key. - name this key and ssh-keygen stores keys as your_name and your_name.pub. - default location for keys is under ~/.ssh copy we already have password access to the remote machine, but we're tired of entering all that every time we log on. WE WANTS \"Passwordless\", so : ssh-copy-id -i _identity-file_ user@some_host and now remote is happy because our public key is in its authorized_keys file. connect with generated key ssh -i ~/.ssh/id_rsa user@some_host -i tells ssh to use a specific key - here it's .ssh/id_rsa now \"some_host\" lets us in after we reply correctly to the message it sends us encrypted by our public key. ~/.ssh/config Host gitlab.com Hostname gitlab.com User git IdentityFile ~/.ssh/id-notavm-glab User username config has one stanza per remote, starting \"Host\", then indented statements. config has many uses - here it associates gitlab to the correct IdentityFile. is it completely necessary when using ssh-agent ? authorized_keys holds public keys (copied here by a trusted user) that enable a remote box to connect to us. the remote user runs : ssh-copy-id -i ~/.ssh/hand_rsa_key user@some_host_ip and gets prompted for their password before ssh copies the key. now the remote with the matching private key can connect without further auth. using: ssh -i ~/.ssh/hand_rsa_key user@some_host_ip though they must specify the correct key ( -i , option ) known_hosts list of entries, usually of 3 fields ip or hostname, type of cert, and public key in ascii. your personal certificate authority. You are ascerting to your OS that you have validated these server keys. note that ubuntu hashes the ip/hostname to a fingerprint for additional security. servers present their public keys upon your request to connect and ssh checks with known_hosts before proceeding. If everything matches proceed to connect. If only part of record matches then ssh gives user a huge WARNING. If first time seeing this key then ssh asks if you want to add it to known_hosts. ssh-agent a helper program for key mgmt convenience if keys are passworded the agent remembers that throughout a session multi hop without divulging keys : the agent is able to network authentication traffic betwix your local machine and some server via intermediary machines to which one has already ssh'd. - on linux/kde it starts at boot and that's it. (is this true !) manual start with eval $(ssh-agent) (ssh-agent expands to a semi colon separated list of commands that initiates the process and env.) to limit the agent to this shell use eval $(ssh-agent $SHELL) and to kill eval $(ssh-agent -k) ssh-add add a key to ssh-agent. Key is now in memory owned by ssh-agent. ssh-add -l & ssh-add -L list fingerprints & list keys, known to ssh-agent ssh-add -D delete all keys known to ssh-agent ssh-add -A delivers your keys to a remote box so that box can then access another server. ssh fingerprints a hash of the public key, aka fingerprint, currently it's a SHA256 output as base64 show with: ssh-add -l or ssh-keygen ~/.ssh/id_rsa.pub and manually, it's a guddle, since on linux sha256sum ouputs hex : cat id_rsa.pub | cut -d' ' -f2 | base64 -d | sha256sum | cut -d' ' -f1 | xxd -r -p | base64 | sed 's/=*$//'","title":"tl:dr"},{"location":"ssh/#generate-copy-connect","text":"","title":"generate, copy, connect !"},{"location":"ssh/#keygen","text":"lets say we do ed25519 ssh-keygen -o -a 100 -t ed25519 - o signifies an option follows - a is argument to -o, says to do 100 \"rounds\" - this option specifies the number of KDF (key derivation function) rounds to use. Higher numbers result in slower passphrase verification and increased resistance to brute- force password cracking. - passphrase (aka fingerprint) is optional - it secures the private key. - name this key and ssh-keygen stores keys as your_name and your_name.pub. - default location for keys is under ~/.ssh","title":"keygen"},{"location":"ssh/#copy","text":"we already have password access to the remote machine, but we're tired of entering all that every time we log on. WE WANTS \"Passwordless\", so : ssh-copy-id -i _identity-file_ user@some_host and now remote is happy because our public key is in its authorized_keys file.","title":"copy"},{"location":"ssh/#connect-with-generated-key","text":"ssh -i ~/.ssh/id_rsa user@some_host -i tells ssh to use a specific key - here it's .ssh/id_rsa now \"some_host\" lets us in after we reply correctly to the message it sends us encrypted by our public key.","title":"connect with generated key"},{"location":"ssh/#sshconfig","text":"Host gitlab.com Hostname gitlab.com User git IdentityFile ~/.ssh/id-notavm-glab User username config has one stanza per remote, starting \"Host\", then indented statements. config has many uses - here it associates gitlab to the correct IdentityFile. is it completely necessary when using ssh-agent ?","title":"~/.ssh/config"},{"location":"ssh/#authorized_keys","text":"holds public keys (copied here by a trusted user) that enable a remote box to connect to us. the remote user runs : ssh-copy-id -i ~/.ssh/hand_rsa_key user@some_host_ip and gets prompted for their password before ssh copies the key. now the remote with the matching private key can connect without further auth. using: ssh -i ~/.ssh/hand_rsa_key user@some_host_ip though they must specify the correct key ( -i , option )","title":"authorized_keys"},{"location":"ssh/#known_hosts","text":"list of entries, usually of 3 fields ip or hostname, type of cert, and public key in ascii. your personal certificate authority. You are ascerting to your OS that you have validated these server keys. note that ubuntu hashes the ip/hostname to a fingerprint for additional security. servers present their public keys upon your request to connect and ssh checks with known_hosts before proceeding. If everything matches proceed to connect. If only part of record matches then ssh gives user a huge WARNING. If first time seeing this key then ssh asks if you want to add it to known_hosts.","title":"known_hosts"},{"location":"ssh/#ssh-agent","text":"a helper program for key mgmt convenience if keys are passworded the agent remembers that throughout a session multi hop without divulging keys : the agent is able to network authentication traffic betwix your local machine and some server via intermediary machines to which one has already ssh'd.","title":"ssh-agent"},{"location":"ssh/#-on-linuxkde-it-starts-at-boot-and-thats-it-is-this-true","text":"manual start with eval $(ssh-agent) (ssh-agent expands to a semi colon separated list of commands that initiates the process and env.) to limit the agent to this shell use eval $(ssh-agent $SHELL) and to kill eval $(ssh-agent -k) ssh-add add a key to ssh-agent. Key is now in memory owned by ssh-agent. ssh-add -l & ssh-add -L list fingerprints & list keys, known to ssh-agent ssh-add -D delete all keys known to ssh-agent ssh-add -A delivers your keys to a remote box so that box can then access another server.","title":"- on linux/kde it starts at boot and that's it. (is this true !)"},{"location":"ssh/#ssh-fingerprints","text":"a hash of the public key, aka fingerprint, currently it's a SHA256 output as base64 show with: ssh-add -l or ssh-keygen ~/.ssh/id_rsa.pub and manually, it's a guddle, since on linux sha256sum ouputs hex : cat id_rsa.pub | cut -d' ' -f2 | base64 -d | sha256sum | cut -d' ' -f1 | xxd -r -p | base64 | sed 's/=*$//'","title":"ssh fingerprints"},{"location":"ssh/keygen/","text":"","title":"keygen"},{"location":"ssh/keys/","text":"key creation and storage ssh-keygen defines a key type, then generates it key types and their attributes are decently complicated so lets skip all that and just use one of the most prolific (ca. mid 2020), that is considered very secure - ed25519. so: ssh-keygen -o -a 100 -t ed25519 -o signifies that an option follows -a is an argument to -o , says to do 100 \"rounds\" of the key derivation function. passphrase verification is thus slowed, giving increased resistance to brute-force password cracking after key fingerprint is spat out ... supply an optional passphrase, ( highly advised ), to secure the private key name this key and ssh-keygen stores it as some_name and some_name.pub. each pair of keys is known in ssh parlance as an \"IdentityFile\" default location for keys is under ~/.ssh/ ~/.ssh/config Host gitlab.com Hostname gitlab.com User git IdentityFile ~/.ssh/id-notavm-glab User username config has one stanza per remote, starting \"Host\", then indented statements. config has many uses - here it associates gitlab to the correct IdentityFile, thereby allowing an ssh to gitlab to omit the -i option. is it completely necessary when using ssh-agent ? .ssh/known_hosts list of entries, usually of 3 fields :tent: asin ip or hostname, type of cert, and public key in ascii. your personal certificate authority. You are ascerting to your OS that you have validated these server keys. note that ubuntu hashes the ip/hostname to a fingerprint for additional security. servers present their public keys upon your request to connect and ssh checks with known_hosts before proceeding. If everything matches proceed to connect. If only part of record matches then ssh gives user a huge WARNING. If first time seeing this key then ssh asks if you want to add it to known_hosts.","title":"keys"},{"location":"ssh/keys/#key-creation-and-storage","text":"ssh-keygen defines a key type, then generates it key types and their attributes are decently complicated so lets skip all that and just use one of the most prolific (ca. mid 2020), that is considered very secure - ed25519. so: ssh-keygen -o -a 100 -t ed25519 -o signifies that an option follows -a is an argument to -o , says to do 100 \"rounds\" of the key derivation function. passphrase verification is thus slowed, giving increased resistance to brute-force password cracking after key fingerprint is spat out ... supply an optional passphrase, ( highly advised ), to secure the private key name this key and ssh-keygen stores it as some_name and some_name.pub. each pair of keys is known in ssh parlance as an \"IdentityFile\" default location for keys is under ~/.ssh/","title":"key creation and storage"},{"location":"ssh/keys/#sshconfig","text":"Host gitlab.com Hostname gitlab.com User git IdentityFile ~/.ssh/id-notavm-glab User username config has one stanza per remote, starting \"Host\", then indented statements. config has many uses - here it associates gitlab to the correct IdentityFile, thereby allowing an ssh to gitlab to omit the -i option. is it completely necessary when using ssh-agent ?","title":"~/.ssh/config"},{"location":"ssh/keys/#sshknown_hosts","text":"list of entries, usually of 3 fields :tent: asin ip or hostname, type of cert, and public key in ascii. your personal certificate authority. You are ascerting to your OS that you have validated these server keys. note that ubuntu hashes the ip/hostname to a fingerprint for additional security. servers present their public keys upon your request to connect and ssh checks with known_hosts before proceeding. If everything matches proceed to connect. If only part of record matches then ssh gives user a huge WARNING. If first time seeing this key then ssh asks if you want to add it to known_hosts.","title":".ssh/known_hosts"},{"location":"ssh/security/","text":"","title":"security"},{"location":"ssh/ssh-agent/","text":"","title":"ssh-agent"},{"location":"ssh/ssh/","text":"ssh ssh-keygen connect with a key config file authorized_keys & ssh-copy-id known_hosts & server authentication ssh-agent ssh-add, ssh-add -l, ssh-add -A recover hung session: type ~. (tilde period) fingerprints https://www.ssh.com keygen lets say we do ed25519 ssh-keygen -o -a 100 -t ed25519 - -o signifies an option follows - -a is argument to -o, says to do 100 \"rounds\" - this option specifies the number of KDF (key derivation function) rounds to use. Higher numbers result in slower passphrase verification and increased resistance to brute- force password cracking. - passphrase (aka fingerprint) is optional - it secures the private key. - name this key and ssh-keygen stores keys as your_name and your_name.pub. - default location for keys is under ~/.ssh connect with generated key ssh -i ~/.ssh/id_rsa user@some_host_ip - -i tells ssh to use a specific key (id) - here it's .ssh/id_rsa ~/.ssh/config Host gitlab.com Hostname gitlab.com User git IdentityFile ~/.ssh/id-notavm-glab User username config has one stanza per remote, starting \"Host\", then indented statements. config has many uses - here it associates gitlab to the correct IdentityFile. is it completely necessary when using ssh-agent ? authorized_keys holds public keys (copied here by a trusted user) that enable a remote box to connect to us. the remote user runs : ssh-copy-id -i ~/.ssh/hand_rsa_key user@some_host_ip and gets prompted for their password before ssh copies the key. now the remote with the matching private key can connect without further auth. using: ssh -i ~/.ssh/hand_rsa_key user@some_host_ip though they must specify the correct key ( -i , option ) known_hosts list of entries, usually of 3 fields ip or hostname, type of cert, and public key in ascii. your personal certificate authority. You are ascerting to your OS that you have validated these server keys. note that ubuntu hashes the ip/hostname to a fingerprint for additional security. servers present their public keys upon your request to connect and ssh checks with known_hosts before proceeding. If everything matches proceed to connect. If only part of record matches then ssh gives user a huge WARNING. If first time seeing this key then ssh asks if you want to add it to known_hosts. ssh-agent a helper program for key mgmt convenience if keys are passworded the agent remembers that throughout a session multi hop without divulging keys : the agent is able to network authentication traffic betwix your local machine and some server via intermediary machines to which one has already ssh'd. - on linux/kde it starts at boot and that's it. (is this true !) manual start with eval $(ssh-agent) (ssh-agent expands to a semi colon separated list of commands that initiates the process and env.) to limit the agent to this shell use eval $(ssh-agent $SHELL) and to kill eval $(ssh-agent -k) ssh-add add a key to ssh-agent. Key is now in memory owned by ssh-agent. ssh-add -l & ssh-add -L list fingerprints & list keys, known to ssh-agent ssh-add -D delete all keys known to ssh-agent ssh-add -A delivers your keys to a remote box so that box can then access another server. ssh fingerprints a hash of the public key, aka fingerprint, currently it's a SHA256 output as base64 show with: ssh-add -l or ssh-keygen ~/.ssh/id_rsa.pub and manually, it's a guddle, since on linux sha256sum ouputs hex : cat id_rsa.pub | cut -d' ' -f2 | base64 -d | sha256sum | cut -d' ' -f1 | xxd -r -p | base64 | sed 's/=*$//'","title":"Ssh"},{"location":"ssh/ssh/#ssh","text":"ssh-keygen connect with a key config file authorized_keys & ssh-copy-id known_hosts & server authentication ssh-agent ssh-add, ssh-add -l, ssh-add -A recover hung session: type ~. (tilde period) fingerprints https://www.ssh.com","title":"ssh"},{"location":"ssh/ssh/#keygen","text":"lets say we do ed25519 ssh-keygen -o -a 100 -t ed25519 - -o signifies an option follows - -a is argument to -o, says to do 100 \"rounds\" - this option specifies the number of KDF (key derivation function) rounds to use. Higher numbers result in slower passphrase verification and increased resistance to brute- force password cracking. - passphrase (aka fingerprint) is optional - it secures the private key. - name this key and ssh-keygen stores keys as your_name and your_name.pub. - default location for keys is under ~/.ssh","title":"keygen"},{"location":"ssh/ssh/#connect-with-generated-key","text":"ssh -i ~/.ssh/id_rsa user@some_host_ip - -i tells ssh to use a specific key (id) - here it's .ssh/id_rsa","title":"connect with generated key"},{"location":"ssh/ssh/#sshconfig","text":"Host gitlab.com Hostname gitlab.com User git IdentityFile ~/.ssh/id-notavm-glab User username config has one stanza per remote, starting \"Host\", then indented statements. config has many uses - here it associates gitlab to the correct IdentityFile. is it completely necessary when using ssh-agent ?","title":"~/.ssh/config"},{"location":"ssh/ssh/#authorized_keys","text":"holds public keys (copied here by a trusted user) that enable a remote box to connect to us. the remote user runs : ssh-copy-id -i ~/.ssh/hand_rsa_key user@some_host_ip and gets prompted for their password before ssh copies the key. now the remote with the matching private key can connect without further auth. using: ssh -i ~/.ssh/hand_rsa_key user@some_host_ip though they must specify the correct key ( -i , option )","title":"authorized_keys"},{"location":"ssh/ssh/#known_hosts","text":"list of entries, usually of 3 fields ip or hostname, type of cert, and public key in ascii. your personal certificate authority. You are ascerting to your OS that you have validated these server keys. note that ubuntu hashes the ip/hostname to a fingerprint for additional security. servers present their public keys upon your request to connect and ssh checks with known_hosts before proceeding. If everything matches proceed to connect. If only part of record matches then ssh gives user a huge WARNING. If first time seeing this key then ssh asks if you want to add it to known_hosts.","title":"known_hosts"},{"location":"ssh/ssh/#ssh-agent","text":"a helper program for key mgmt convenience if keys are passworded the agent remembers that throughout a session multi hop without divulging keys : the agent is able to network authentication traffic betwix your local machine and some server via intermediary machines to which one has already ssh'd.","title":"ssh-agent"},{"location":"ssh/ssh/#-on-linuxkde-it-starts-at-boot-and-thats-it-is-this-true","text":"manual start with eval $(ssh-agent) (ssh-agent expands to a semi colon separated list of commands that initiates the process and env.) to limit the agent to this shell use eval $(ssh-agent $SHELL) and to kill eval $(ssh-agent -k) ssh-add add a key to ssh-agent. Key is now in memory owned by ssh-agent. ssh-add -l & ssh-add -L list fingerprints & list keys, known to ssh-agent ssh-add -D delete all keys known to ssh-agent ssh-add -A delivers your keys to a remote box so that box can then access another server.","title":"- on linux/kde it starts at boot and that's it. (is this true !)"},{"location":"ssh/ssh/#ssh-fingerprints","text":"a hash of the public key, aka fingerprint, currently it's a SHA256 output as base64 show with: ssh-add -l or ssh-keygen ~/.ssh/id_rsa.pub and manually, it's a guddle, since on linux sha256sum ouputs hex : cat id_rsa.pub | cut -d' ' -f2 | base64 -d | sha256sum | cut -d' ' -f1 | xxd -r -p | base64 | sed 's/=*$//'","title":"ssh fingerprints"}]}